{
  "hash": "202462e61b6108bd54e01778cf21611b",
  "result": {
    "markdown": "---\ntitle: Tree models in ChEMBL data\nsubtitle: ML series 2.1 - decision tree - data pre-processing (part 1)\nauthor: Jennifer HY Lin\ndate: 2023-9-4\ndraft: true\ncategories:\n  - Machine learning projects\n  - Pandas\n  - ChEMBL database\nformat: html\nbibliography: references.bib\n---\n\n#### **Introduction**\n\nI've now come to a stage to do some more in-depth machine learning work after reading some peer-reviewed papers about it in relation to drug discovery and cheminformatics. Previously, I've only lightly touched on a commonly used classifier algorithm, logistic regression, as the first series in the machine learning realm. Reflecting back, I think I could've done a more thorough job during the data preparation stage. So this would be attempted this time.\n\nFrom a few of the papers I've read so far, dated in the recent years of 2021 and 2022, it seems that traditional machine learning (ML) methods are still indispensible performance-wise, and when used in combination with deep learning neural networks, they tend to increase prediction accuracy more in the drug discovery field. I haven't ventured into the practicality and usefulness of large language models in drug discovery yet. However, comments from experienced seniors in this area did mention that they are still very much novel and hence may not as useful yet (however by the speed of how things evolve in the so-called \"AI\" field currently, perhaps this may change when this post gets published?), and from what I can imagine, molecular representations in texts or strings (such as SMILES or SELFIES) are not quite the same as natural language texts, as there are a lot of other chemistry-specific things to consider e.g. chiralities, aromaticities and so on. Because of this, I'm sticking with learning to walk first in the conventional ML area (trying to cover it in a more thorough way) before trying to run in the deep learning zone.\n\nThe data preparation used here was carried out with strong reference to the materials and methods section in this paper [@vantilborg2022]. There are probably other methods out there, but this was the paper that had made sense and relatively easy to follow when I read it earlier.\n\n<br>\n\n#### **Data retrieval**\n\nThis time I decided to try something new which was to use the ChEMBL webresource client to collect data (i.e. not by direct file downloads from ChEMBL website, although other useful way could be through SQL queries, which is also on my list to try later). I found this great online resource about fetching data this way from the TeachOpenCADD talktorial on [compound data acquisition](https://projects.volkamerlab.org/teachopencadd/talktorials/T001_query_chembl.html). The data retrieval workflow used below was mainly adapted from this talktorial, but with a few changes to suit the selected dataset and machine learning model selected for this ML series 2 project.\n\nThe webresource client was supported by the ChEMBL group and was based on a Django QuerySet interface. Their [GitHub repository](https://github.com/chembl/chembl_webresource_client) might explain a bit more about it, particularly the Jupyter notebook link provided within the repository would help a lot regarding how to write code to search for specific data.\n\nTo do this, a few libraries needed to be loaded first.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# Import libraries\n# Fetch data through ChEMBL webresource client\nfrom chembl_webresource_client.new_client import new_client\n\n# Dataframe library\nimport pandas as pd\n\n# Progress bar\nfrom tqdm import tqdm\n```\n:::\n\n\nTo see what types of data were provided by ChEMBL webresource client, run the following code and refer to ChEMBL documentations to find out what data were embedded inside different data categories. Sometimes, it might not be that straight forward and some digging would be required (I went back to this step below to find the \"[data_validity_comment](http://chembl.blogspot.com/2020/10/data-checks.html)\" when I was trying to do some compound sanitisations actually).\n\n::: callout-note\nThe link provided above also talked about other useful techniques for data checks in the ChEMBL database - a very important step to do during data pre-processing, which was also something I was trying to cover and achieve as much as possible in this post.\n:::\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\navailable_resources = [resource for resource in dir(new_client) if not resource.startswith('_')]\nprint(available_resources)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['activity', 'activity_supplementary_data_by_activity', 'assay', 'assay_class', 'atc_class', 'binding_site', 'biotherapeutic', 'cell_line', 'chembl_id_lookup', 'compound_record', 'compound_structural_alert', 'description', 'document', 'document_similarity', 'drug', 'drug_indication', 'drug_warning', 'go_slim', 'image', 'mechanism', 'metabolism', 'molecule', 'molecule_form', 'official', 'organism', 'protein_classification', 'similarity', 'source', 'substructure', 'target', 'target_component', 'target_relation', 'tissue', 'xref_source']\n```\n:::\n:::\n\n\nResource objects were created to enable API access as suggested by the talktorial.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# for targets (proteins)\ntargets_api = new_client.target\n\n# for bioactivities\nbioact_api = new_client.activity\n\n# for compounds\ncpd_api = new_client.molecule\n```\n:::\n\n\nChecked object type for one of these API objects (e.g. bioactivity API object).\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ntype(bioact_api)\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\nchembl_webresource_client.query_set.QuerySet\n```\n:::\n:::\n\n\n<br>\n\n##### **Fetching target data**\n\nA protein target e.g. acetylcholinesterase was randomly chosen by using [UniProt](https://www.uniprot.org/) to look up the protein UniProt ID.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Specify Uniprot ID for acetylcholinesterase\nuniprot_id = \"P22303\"\n\n# Get info from ChEMBL about this protein target, \n# with selected features only\ntargets = targets_api.get(target_components__accession = uniprot_id).only(\n    \"target_chembl_id\",\n    \"organism\", \n    \"pref_name\", \n    \"target_type\"\n)\n```\n:::\n\n\nThe query results were stored in a \"targets\" object, which was a QuerySet with lazy data evaluation only, meaning it would only react when there was a request for the data. Therefore, to see the results, the \"targets\" object was then read through Pandas DataFrame.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Read \"targets\" with Pandas\ntargets = pd.DataFrame.from_records(targets)\ntargets\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>organism</th>\n      <th>pref_name</th>\n      <th>target_chembl_id</th>\n      <th>target_type</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Homo sapiens</td>\n      <td>Acetylcholinesterase</td>\n      <td>CHEMBL220</td>\n      <td>SINGLE PROTEIN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Homo sapiens</td>\n      <td>Acetylcholinesterase</td>\n      <td>CHEMBL220</td>\n      <td>SINGLE PROTEIN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Homo sapiens</td>\n      <td>Cholinesterases; ACHE &amp; BCHE</td>\n      <td>CHEMBL2095233</td>\n      <td>SELECTIVITY GROUP</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nSelected the first protein target from this dataframe.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Save the first protein in the dataframe\nselect_target = targets.iloc[0]\nselect_target\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\norganism                    Homo sapiens\npref_name           Acetylcholinesterase\ntarget_chembl_id               CHEMBL220\ntarget_type               SINGLE PROTEIN\nName: 0, dtype: object\n```\n:::\n:::\n\n\nThen saved the selected ChEMBL ID for the first protein (to be used later).\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nchembl_id = select_target.target_chembl_id\n# Check it's saved\nprint(chembl_id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCHEMBL220\n```\n:::\n:::\n\n\n<br>\n\n##### **Fetching bioactivity data**\n\nObtaining bioactivity data for the selected target.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nbioact = bioact_api.filter(\n    # Use the previously saved target ChEMBL ID\n    target_chembl_id = chembl_id, \n    # Selecting for Ki\n    standard_type = \"Ki\",\n    # Requesting exact measurements\n    relation = \"=\",\n    # Binding data as \"B\"\n    assay_type = \"B\",\n).only(\n    \"activity_id\",\n    \"data_validity_comment\"\n    \"assay_chembl_id\",\n    \"assay_description\",\n    \"assay_type\",\n    \"molecule_chembl_id\",\n    \"standard_units\",\n    \"standard_type\",\n    \"relation\",\n    \"standard_value\",\n    \"target_chembl_id\",\n    \"target_organism\",\n)\n\n# Check the length and type of bioactivities object\nprint(len(bioact), type(bioact))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n706 <class 'chembl_webresource_client.query_set.QuerySet'>\n```\n:::\n:::\n\n\nTo have a quick look at the data being held inside each entry of the bioactivity dataset, e.g. for first entry.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nprint(len(bioact[0]), type(bioact[0]))\nbioact[0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n15 <class 'dict'>\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\n{'activity_id': 111024,\n 'assay_chembl_id': 'CHEMBL641011',\n 'assay_description': 'Inhibition constant determined against Acetylcholinesterase (AChE) receptor.',\n 'assay_type': 'B',\n 'data_validity_comment': 'Potential transcription error',\n 'molecule_chembl_id': 'CHEMBL11805',\n 'relation': '=',\n 'standard_type': 'Ki',\n 'standard_units': 'nM',\n 'standard_value': '0.104',\n 'target_chembl_id': 'CHEMBL220',\n 'target_organism': 'Homo sapiens',\n 'type': 'Ki',\n 'units': 'nM',\n 'value': '0.104'}\n```\n:::\n:::\n\n\nThe next step might take a few minutes (if using a different protein target) - downloading the QuerySet as a Pandas DataFrame.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nbioact_df = pd.DataFrame.from_dict(bioact)\n\nbioact_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>activity_id</th>\n      <th>assay_chembl_id</th>\n      <th>assay_description</th>\n      <th>assay_type</th>\n      <th>data_validity_comment</th>\n      <th>molecule_chembl_id</th>\n      <th>relation</th>\n      <th>standard_type</th>\n      <th>standard_units</th>\n      <th>standard_value</th>\n      <th>target_chembl_id</th>\n      <th>target_organism</th>\n      <th>type</th>\n      <th>units</th>\n      <th>value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>111024</td>\n      <td>CHEMBL641011</td>\n      <td>Inhibition constant determined against Acetylc...</td>\n      <td>B</td>\n      <td>Potential transcription error</td>\n      <td>CHEMBL11805</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>0.104</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>0.104</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>118575</td>\n      <td>CHEMBL641012</td>\n      <td>Inhibitory activity against human AChE</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL208599</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>0.026</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>0.026</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>125075</td>\n      <td>CHEMBL641011</td>\n      <td>Inhibition constant determined against Acetylc...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL60745</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>1.63</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>1.63</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>733829</td>\n      <td>CHEMBL641691</td>\n      <td>Inhibitory activity of compound against acetyl...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL95</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>151.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>151.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>740235</td>\n      <td>CHEMBL641013</td>\n      <td>Inhibitory activity of compound against acetyl...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL173309</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>12.2</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>12.2</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nChecked total rows and columns in the bioactivities dataframe.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nbioact_df.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\n(706, 15)\n```\n:::\n:::\n\n\n<br>\n\n###### **Pre-process bioactivity data**\n\nWhen I reached the second half of data pre-processing, an alarm bell went off regarding using half maximal inhibitory concentration (IC50) values in ChEMBL. I remembered reading recent blog posts by Greg Landrum about using [IC50](https://greglandrum.github.io/rdkit-blog/posts/2023-06-12-overlapping-ic50-assays1.html) and inhibition constant ([Ki](https://greglandrum.github.io/rdkit-blog/posts/2023-06-17-overlapping-Ki-assays1.html)) values from ChEMBL. A useful open-access paper [@Kalliokoski2013a] from 2013 also looked into this issue about using mixed IC50 data in ChEMBL, and provided a thorough overview about how to deal with situations like this. There was also another paper [@Kramer2012] on mixed Ki data from the same author group in 2012 that touched on similar issues (unfortunately this wasn't an open-access paper so I only looked at the abstract).\n\nTo summarise both the paper about IC50 and blog posts mentioned above:\n\n-   it would be the best to check the details of assays used to test the compounds to ensure they were aligned and not extremely heterogeneous, since IC50 values were very assay-specific, and knowing that these values were extracted from different papers from different labs all over the world, mixing them without knowing was definitely not a good idea\n\n-   the slightly better news was that it was more likely okay to combine Ki values for the same protein target from ChEMBL as they were found to be adding less noise to the data (however ideally similar data caution should also apply)\n\n-   it was also possible to mix Ki values with IC50 values, but the data would need to be corrected via using a conversion factor of 2.0 to convert Ki values to IC50 values (note: I also wondered if this needed to be re-looked again, since this paper was published 10 years ago...)\n\nBecause of this, I decided to stick with Ki values only for now before adding more complexities as I wasn't entirely confident about mixing IC50 values with Ki values yet. Firstly, I checked for all types of units being used in bioact_df. There were numerous different units and formats, which meant they would need to be converted to nanomolar (nM).\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nbioact_df[\"units\"].unique()\n```\n\n::: {.cell-output .cell-output-display execution_count=56}\n```\narray(['nM', 'M', 'uM', None, 'pM', \"10'-9M\", \"10'-3M\", \"10'-6M\",\n       \"10'-10M\", '/min/M', \"10'5/M/min\", \"10'2/M/min\", \"10'3/M/min\",\n       \"10'8/M/min\", \"10'7/M/min\", 'microM/L', 'umol/L', 'mM',\n       \"10'4/M/min\", \"10'6/M/min\", 'mM/min', '10^8M'], dtype=object)\n```\n:::\n:::\n\n\nChecking again that I've fetched Ki values only.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nbioact_df[\"standard_type\"].unique()\n```\n\n::: {.cell-output .cell-output-display execution_count=57}\n```\narray(['Ki'], dtype=object)\n```\n:::\n:::\n\n\nIt looked like there were duplicates of columns on units and values - removing \"units\" and \"value\" columns and keeping \"standard_units\" and \"standard_value\" columns instead. Also, \"type\" column was dropped as there were already a \"standard_type\" column.\n\n::: callout-note\nDifferences between \"type\" and \"standard_type\" columns were mentioned by this ChEMBL [blog post](https://chembl.blogspot.com/2013/02/latest-activities-on-activities-table.html).\n:::\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nbioact_df.drop([\"units\", \"value\", \"type\"], axis = 1, inplace = True)\n# Re-check df\nbioact_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=58}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>activity_id</th>\n      <th>assay_chembl_id</th>\n      <th>assay_description</th>\n      <th>assay_type</th>\n      <th>data_validity_comment</th>\n      <th>molecule_chembl_id</th>\n      <th>relation</th>\n      <th>standard_type</th>\n      <th>standard_units</th>\n      <th>standard_value</th>\n      <th>target_chembl_id</th>\n      <th>target_organism</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>111024</td>\n      <td>CHEMBL641011</td>\n      <td>Inhibition constant determined against Acetylc...</td>\n      <td>B</td>\n      <td>Potential transcription error</td>\n      <td>CHEMBL11805</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>0.104</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>118575</td>\n      <td>CHEMBL641012</td>\n      <td>Inhibitory activity against human AChE</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL208599</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>0.026</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>125075</td>\n      <td>CHEMBL641011</td>\n      <td>Inhibition constant determined against Acetylc...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL60745</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>1.63</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>733829</td>\n      <td>CHEMBL641691</td>\n      <td>Inhibitory activity of compound against acetyl...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL95</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>151.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>740235</td>\n      <td>CHEMBL641013</td>\n      <td>Inhibitory activity of compound against acetyl...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL173309</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>12.2</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nbioact_df.dtypes\n```\n\n::: {.cell-output .cell-output-display execution_count=59}\n```\nactivity_id               int64\nassay_chembl_id          object\nassay_description        object\nassay_type               object\ndata_validity_comment    object\nmolecule_chembl_id       object\nrelation                 object\nstandard_type            object\nstandard_units           object\nstandard_value           object\ntarget_chembl_id         object\ntarget_organism          object\ndtype: object\n```\n:::\n:::\n\n\nThe column of \"standard_value\" was converted from \"object\" to \"float64\" so we could use the Ki values for calculations later.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nbioact_df = bioact_df.astype({\"standard_value\": \"float64\"})\n# Check column data types again\nbioact_df.dtypes\n```\n\n::: {.cell-output .cell-output-display execution_count=60}\n```\nactivity_id                int64\nassay_chembl_id           object\nassay_description         object\nassay_type                object\ndata_validity_comment     object\nmolecule_chembl_id        object\nrelation                  object\nstandard_type             object\nstandard_units            object\nstandard_value           float64\ntarget_chembl_id          object\ntarget_organism           object\ndtype: object\n```\n:::\n:::\n\n\nThen the next step was taking care of any missing entries by removing them in the first place. I excluded \"data_validity_comment\" column here as this was required to check if there were any unusual activity data e.g. excessively low or high Ki values. A lot of the compounds in this column probably had empty cells or \"None\", which ensured that there were no particular alarm bells to the extracted bioactivity data.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nbioact_df.dropna(subset = [\"activity_id\", \"assay_chembl_id\", \"assay_description\", \"assay_type\", \"molecule_chembl_id\", \"relation\",  \"standard_type\", \"standard_units\", \"standard_value\", \"target_chembl_id\", \"target_organism\"], axis = 0, how = \"any\", inplace = True)\n# Check number of rows and columns again (in this case, there appeared to be no change for rows)\nbioact_df.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=61}\n```\n(706, 12)\n```\n:::\n:::\n\n\nSince all unique units inside the \"units\" and \"values\" columns were checked previously, I'd done the same for the \"standard_units\" column to see the ones recorded in it.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nbioact_df[\"standard_units\"].unique()\n```\n\n::: {.cell-output .cell-output-display execution_count=62}\n```\narray(['nM', '/min/M', \"10'5/M/min\", \"10'2/M/min\", \"10'3/M/min\",\n       \"10'8/M/min\", \"10'7/M/min\", \"10'4/M/min\", \"10'6/M/min\", 'mM/min',\n       '10^8M'], dtype=object)\n```\n:::\n:::\n\n\nThere were a mixture of different units.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# Check for number of non-nM units\nbioact_df[bioact_df[\"standard_units\"] != \"nM\"].shape[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=63}\n```\n61\n```\n:::\n:::\n\n\nThere appeared to be 61 non-nM values inside the fetched bioactivity data.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nbioact_df = bioact_df[bioact_df[\"standard_units\"] == \"nM\"]\n```\n:::\n\n\nI then narrowed the results to only \"nM\" and checked the dataframe again to see what units were left now.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# Check there were only nM\nbioact_df[\"standard_units\"].unique()\n```\n\n::: {.cell-output .cell-output-display execution_count=65}\n```\narray(['nM'], dtype=object)\n```\n:::\n:::\n\n\nSo the filtering worked and the number of rows and columns were reduced.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# Check df rows & columns\nbioact_df.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=66}\n```\n(645, 12)\n```\n:::\n:::\n\n\nNext part would be to remove all the duplicates in the dataframe, especially when there were duplicate tests for the same compound.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nbioact_df.drop_duplicates(\"molecule_chembl_id\", keep = \"first\", inplace = True)\n```\n:::\n\n\nRenamed the \"standard_value\" and \"standard_units\" columns to \"Ki\" and \"units\" respectively.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nbioact_df.rename(\n    columns = {\n        \"standard_value\": \"Ki\",\n        \"standard_units\": \"units\"\n    }, inplace = True\n)\n\n# Check df to ensure name change\nbioact_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=68}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>activity_id</th>\n      <th>assay_chembl_id</th>\n      <th>assay_description</th>\n      <th>assay_type</th>\n      <th>data_validity_comment</th>\n      <th>molecule_chembl_id</th>\n      <th>relation</th>\n      <th>standard_type</th>\n      <th>units</th>\n      <th>Ki</th>\n      <th>target_chembl_id</th>\n      <th>target_organism</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>111024</td>\n      <td>CHEMBL641011</td>\n      <td>Inhibition constant determined against Acetylc...</td>\n      <td>B</td>\n      <td>Potential transcription error</td>\n      <td>CHEMBL11805</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>0.104</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>118575</td>\n      <td>CHEMBL641012</td>\n      <td>Inhibitory activity against human AChE</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL208599</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>0.026</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>125075</td>\n      <td>CHEMBL641011</td>\n      <td>Inhibition constant determined against Acetylc...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL60745</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>1.630</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>733829</td>\n      <td>CHEMBL641691</td>\n      <td>Inhibitory activity of compound against acetyl...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL95</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>151.000</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>740235</td>\n      <td>CHEMBL641013</td>\n      <td>Inhibitory activity of compound against acetyl...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL173309</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>12.200</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nLastly, the index of the dataframe was reset.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nbioact_df.reset_index(drop = True, inplace = True)\nbioact_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=69}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>activity_id</th>\n      <th>assay_chembl_id</th>\n      <th>assay_description</th>\n      <th>assay_type</th>\n      <th>data_validity_comment</th>\n      <th>molecule_chembl_id</th>\n      <th>relation</th>\n      <th>standard_type</th>\n      <th>units</th>\n      <th>Ki</th>\n      <th>target_chembl_id</th>\n      <th>target_organism</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>111024</td>\n      <td>CHEMBL641011</td>\n      <td>Inhibition constant determined against Acetylc...</td>\n      <td>B</td>\n      <td>Potential transcription error</td>\n      <td>CHEMBL11805</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>0.104</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>118575</td>\n      <td>CHEMBL641012</td>\n      <td>Inhibitory activity against human AChE</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL208599</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>0.026</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>125075</td>\n      <td>CHEMBL641011</td>\n      <td>Inhibition constant determined against Acetylc...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL60745</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>1.630</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>733829</td>\n      <td>CHEMBL641691</td>\n      <td>Inhibitory activity of compound against acetyl...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL95</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>151.000</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>740235</td>\n      <td>CHEMBL641013</td>\n      <td>Inhibitory activity of compound against acetyl...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL173309</td>\n      <td>=</td>\n      <td>Ki</td>\n      <td>nM</td>\n      <td>12.200</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nOne final check on the number of columns and rows after pre-processing the bioactivity dataframe.\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nbioact_df.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=70}\n```\n(540, 12)\n```\n:::\n:::\n\n\nThere were a total of 12 columns with 540 rows of data left in the bioactivity dataframe.\n\n<br>\n\n##### **Fetching compound data**\n\nWhile having identified the protein target and obtained the bioactivity data, this step was to link the bioactivity data to the compound data.\n\nThis could be done by having the ChEMBL IDs available for the compounds in the bioactivity dataset.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\ncpds = cpd_api.filter(\n    molecule_chembl_id__in = list(bioact_df[\"molecule_chembl_id\"])\n).only(\n    \"molecule_chembl_id\",\n    \"molecule_structures\"\n)\n```\n:::\n\n\nHere, the same step was applied where the compound QuerySet object was converted into a Pandas dataframe. However, the dataset extracted this time could take longer than the time taken to fetch the bioactivity data. This was then monitored using a progress bar (tqdm package).\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# Uncomment line below to use progress bar\n# when running in ipynb or qmd files\ncompds = list(tqdm(cpds))\n\n# Code below was the same as above, \n# except without the progress bar\n# - to remove images of progress bar for published version\n#compds = list(cpds)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\r  0%|          | 0/540 [00:00<?, ?it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 96%|█████████▋| 521/540 [00:00<00:00, 5064.25it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r100%|██████████| 540/540 [00:00<00:00, 5198.75it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n:::\n\n\nConverting retrieved compound QuerySet into a Pandas DataFrame.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\ncpds_df = pd.DataFrame.from_records(compds)\nprint(cpds_df.shape)\ncpds_df.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(540, 2)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=73}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>molecule_structures</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL28</td>\n      <td>{'canonical_smiles': 'O=c1cc(-c2ccc(O)cc2)oc2c...</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL50</td>\n      <td>{'canonical_smiles': 'O=c1c(O)c(-c2ccc(O)c(O)c...</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL8320</td>\n      <td>{'canonical_smiles': 'O=C1C=CC(=O)C=C1', 'molf...</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL481</td>\n      <td>{'canonical_smiles': 'CCc1c2c(nc3ccc(OC(=O)N4C...</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL95</td>\n      <td>{'canonical_smiles': 'Nc1c2c(nc3ccccc13)CCCC2'...</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\n###### **Pre-process compound data**\n\nRemoving any missing entries in the compound data.\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\ncpds_df.dropna(axis = 0, how = \"any\", inplace = True)\n\n# Check columns & rows in df\ncpds_df.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=74}\n```\n(540, 2)\n```\n:::\n:::\n\n\nRemoving any duplicates in the compound data.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\ncpds_df.drop_duplicates(\"molecule_chembl_id\", keep = \"first\", inplace = True)\n\n# Check columns & rows again\ncpds_df.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=75}\n```\n(540, 2)\n```\n:::\n:::\n\n\nIdeally, only the compounds with canonical SMILES would be kept. Checking for the types of molecular representations used in the \"molecule_structures\" column of the compound dataset.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# Randomly choosing the 2nd entry as example\ncpds_df.iloc[1].molecule_structures.keys()\n```\n\n::: {.cell-output .cell-output-display execution_count=76}\n```\ndict_keys(['canonical_smiles', 'molfile', 'standard_inchi', 'standard_inchi_key'])\n```\n:::\n:::\n\n\nThere were 4 types: \"canonical_smiles\", \"molfile\", \"standard_inchi\" and \"standard_inchi_key\".\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# Create an empty list to store the canonical smiles\ncan_smiles = []\n\n# Create a for loop to loop over each row of data, \n# searching for only canonical_smiles to append to the created list\nfor i, cpd in cpds_df.iterrows():\n    try:\n        can_smiles.append(cpd[\"molecule_structures\"][\"canonical_smiles\"])\n    except KeyError:\n        can_smiles.append(None)\n\n# Create a new df column with name as \"smiles\", \n# which will store all the canonical smiles collected from the list above\ncpds_df[\"smiles\"] = can_smiles\n```\n:::\n\n\nCheck the compound dataframe quickly to see if a new column for SMILES has been created.\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\ncpds_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=78}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>molecule_structures</th>\n      <th>smiles</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL28</td>\n      <td>{'canonical_smiles': 'O=c1cc(-c2ccc(O)cc2)oc2c...</td>\n      <td>O=c1cc(-c2ccc(O)cc2)oc2cc(O)cc(O)c12</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL50</td>\n      <td>{'canonical_smiles': 'O=c1c(O)c(-c2ccc(O)c(O)c...</td>\n      <td>O=c1c(O)c(-c2ccc(O)c(O)c2)oc2cc(O)cc(O)c12</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL8320</td>\n      <td>{'canonical_smiles': 'O=C1C=CC(=O)C=C1', 'molf...</td>\n      <td>O=C1C=CC(=O)C=C1</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL481</td>\n      <td>{'canonical_smiles': 'CCc1c2c(nc3ccc(OC(=O)N4C...</td>\n      <td>CCc1c2c(nc3ccc(OC(=O)N4CCC(N5CCCCC5)CC4)cc13)-...</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL95</td>\n      <td>{'canonical_smiles': 'Nc1c2c(nc3ccccc13)CCCC2'...</td>\n      <td>Nc1c2c(nc3ccccc13)CCCC2</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nOnce confirmed, the old \"molecule_structures\" column was then removed.\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\ncpds_df.drop(\"molecule_structures\", axis = 1, inplace = True)\n```\n:::\n\n\nFinally, adding another step to ensure all missing entries or entries without canonical SMILES strings were removed from the compound dataset.\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\ncpds_df.dropna(axis = 0, how = \"any\", inplace = True)\n\nprint(cpds_df.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(540, 2)\n```\n:::\n:::\n\n\nFinal look at the compound dataset, which should only include compounds ChEMBL IDs and SMILES columns.\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\ncpds_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=81}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>smiles</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL28</td>\n      <td>O=c1cc(-c2ccc(O)cc2)oc2cc(O)cc(O)c12</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL50</td>\n      <td>O=c1c(O)c(-c2ccc(O)c(O)c2)oc2cc(O)cc(O)c12</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL8320</td>\n      <td>O=C1C=CC(=O)C=C1</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL481</td>\n      <td>CCc1c2c(nc3ccc(OC(=O)N4CCC(N5CCCCC5)CC4)cc13)-...</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL95</td>\n      <td>Nc1c2c(nc3ccccc13)CCCC2</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\n##### **Combining bioactivity and compound data**\n\nTo combine both datasets, the key was to look for common column (similar to a SQL \"join\" query) between the two datasets.\n\nListing all the column names for both datasets would show the common column.\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\nbioact_df.columns\n```\n\n::: {.cell-output .cell-output-display execution_count=82}\n```\nIndex(['activity_id', 'assay_chembl_id', 'assay_description', 'assay_type',\n       'data_validity_comment', 'molecule_chembl_id', 'relation',\n       'standard_type', 'units', 'Ki', 'target_chembl_id', 'target_organism'],\n      dtype='object')\n```\n:::\n:::\n\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\ncpds_df.columns\n```\n\n::: {.cell-output .cell-output-display execution_count=83}\n```\nIndex(['molecule_chembl_id', 'smiles'], dtype='object')\n```\n:::\n:::\n\n\nClearly, the column that existed in both dataframes was the \"molecule_chembl_id\" column.\n\nThe next step was to combine or merge both datasets.\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\n# Create a final dataframe that will contain both bioactivity and compound data\ndtree_df = pd.merge(\n    bioact_df[[\"molecule_chembl_id\", \"Ki\", \"units\", \"data_validity_comment\"]],\n    cpds_df,\n    on = \"molecule_chembl_id\",\n)\n\ndtree_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=84}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>Ki</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL11805</td>\n      <td>0.104</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>COc1ccccc1CN(C)CCCCCC(=O)N(C)CCCCCCCCN(C)C(=O)...</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL208599</td>\n      <td>0.026</td>\n      <td>nM</td>\n      <td>None</td>\n      <td>CCC1=CC2Cc3nc4cc(Cl)ccc4c(N)c3[C@@H](C1)C2</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL60745</td>\n      <td>1.630</td>\n      <td>nM</td>\n      <td>None</td>\n      <td>CC[N+](C)(C)c1cccc(O)c1.[Br-]</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL95</td>\n      <td>151.000</td>\n      <td>nM</td>\n      <td>None</td>\n      <td>Nc1c2c(nc3ccccc13)CCCC2</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL173309</td>\n      <td>12.200</td>\n      <td>nM</td>\n      <td>None</td>\n      <td>CCN(CCCCCC(=O)N(C)CCCCCCCCN(C)C(=O)CCCCCN(CC)C...</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nRow indices were reset and shape of the final dataframe was checked.\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\ndtree_df.reset_index(drop = True, inplace = True)\n\nprint(dtree_df.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(540, 5)\n```\n:::\n:::\n\n\nSaving a copy of the merged dataframe for now to avoid re-running the previous code repeatedly, and also to be ready for second-half of the data pre-processing work.\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\ndtree_df.to_csv(\"ache_chembl.csv\")\n```\n:::\n\n\nThe second-half of data pre-processing will be carried out in the next post.\n\n",
    "supporting": [
      "Data_prep_1_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}