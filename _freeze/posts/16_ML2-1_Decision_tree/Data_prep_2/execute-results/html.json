{
  "hash": "8bc0a1b733083ea368f1e7a480677e83",
  "result": {
    "markdown": "---\ntitle: Tree models in ChEMBL data\nsubtitle: ML series 2.1 - Decision tree - Data pre-processing 2 of 2\ndraft: true\nformat: html\n---\n\nSince data preparation and cleaning was a well-known process that would take up a lot of time, I've decided to split this part into two posts to ensure the reading time for each post was reasonable.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# Import all libraries used\nimport pandas as pd\nimport math\nimport datamol as dm\n```\n:::\n\n\n<br>\n\n##### **Re-import saved dataframe**\n\nRe-imported the partly pre-processed dtree_df from the earlier post.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndtree_df = pd.read_csv(\"ache_chembl.csv\")\ndtree_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Unnamed: 0</th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>CHEMBL133897</td>\n      <td>750.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CCOc1nn(-c2cccc(OCc3ccccc3)c2)c(=O)o1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1</td>\n      <td>CHEMBL336398</td>\n      <td>100.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC1CC1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2</td>\n      <td>CHEMBL130628</td>\n      <td>300.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC(F)(F)F</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>3</td>\n      <td>CHEMBL130478</td>\n      <td>800.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CSc1nc(-c2ccc(OC(F)(F)F)cc2)nn1C(=O)N(C)C</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>4</td>\n      <td>CHEMBL130112</td>\n      <td>2400.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CSc1nc(-c2ccc(C)cc2)nn1C(=O)N(C)c1ccccc1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNoticed there was an extra index column, likely inherited from how the .csv file was saved, which was subsequently removed.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndtree_df = dtree_df.drop(\"Unnamed: 0\", axis = 1)\ndtree_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL133897</td>\n      <td>750.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CCOc1nn(-c2cccc(OCc3ccccc3)c2)c(=O)o1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL336398</td>\n      <td>100.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC1CC1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL130628</td>\n      <td>300.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC(F)(F)F</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL130478</td>\n      <td>800.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CSc1nc(-c2ccc(OC(F)(F)F)cc2)nn1C(=O)N(C)C</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL130112</td>\n      <td>2400.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CSc1nc(-c2ccc(C)cc2)nn1C(=O)N(C)c1ccccc1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe merged dataframe was found to have IC50 with zero nM, which meant the function to convert IC50 to pIC50 would not proceed (due to natural log of zero normally means undefined answer!). So a good practice to clean data like this was probably best to run a statistical summary such as the code below first, then look for minimum and maximum values and also others to see if there were anything to be tidied up first.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndtree_df.describe()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>IC50</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>count</th>\n      <td>5.040000e+03</td>\n    </tr>\n    <tr>\n      <th>mean</th>\n      <td>8.070638e+04</td>\n    </tr>\n    <tr>\n      <th>std</th>\n      <td>9.511451e+05</td>\n    </tr>\n    <tr>\n      <th>min</th>\n      <td>0.000000e+00</td>\n    </tr>\n    <tr>\n      <th>25%</th>\n      <td>1.000000e+02</td>\n    </tr>\n    <tr>\n      <th>50%</th>\n      <td>1.200000e+03</td>\n    </tr>\n    <tr>\n      <th>75%</th>\n      <td>9.700000e+03</td>\n    </tr>\n    <tr>\n      <th>max</th>\n      <td>4.960000e+07</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nLimiting the IC50 values to be above zero only.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Select IC50 values above zero\ndtree_df = dtree_df[dtree_df[\"IC50\"] > 0.0]\n```\n:::\n\n\nRe-checked the minimum value of IC50 column, which should be above zero.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndtree_df[\"IC50\"].min()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n5e-06\n```\n:::\n:::\n\n\nNow we could convert the IC50 values to pIC50 values (the negative log of IC50 in molar units).\n\nThe key to understand pIC50 here was to treat pIC50 similarly to how we understand pH for our acids and bases. pIC50 was a dimensionless value (so no units actually!) - *useful link*. The formula to convert IC50 to pIC50 for nM units was (**use LaTex for formula**):\n\npIC50 = 9 - log10(IC50)\n\nSet up a small function to do the conversion.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef calc_pIC50(IC50):\n    pIC50_value = 9 - math.log10(IC50)\n    return pIC50_value\n```\n:::\n\n\nApplying the calc_pIC50 function to convert all rows of the compound dataset for the IC50 column.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Create a new column for pIC50\n# Apply calc_pIC50 function to the data in IC50 column\ndtree_df[\"pIC50\"] = dtree_df.apply(lambda x: calc_pIC50(x.IC50), axis = 1)\n```\n:::\n\n\nThe dataframe would now look like this, with a new pIC50 column ready for use.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndtree_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n      <th>pIC50</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL133897</td>\n      <td>750.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CCOc1nn(-c2cccc(OCc3ccccc3)c2)c(=O)o1</td>\n      <td>6.124939</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL336398</td>\n      <td>100.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC1CC1</td>\n      <td>7.000000</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL130628</td>\n      <td>300.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC(F)(F)F</td>\n      <td>6.522879</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL130478</td>\n      <td>800.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CSc1nc(-c2ccc(OC(F)(F)F)cc2)nn1C(=O)N(C)C</td>\n      <td>6.096910</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL130112</td>\n      <td>2400.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CSc1nc(-c2ccc(C)cc2)nn1C(=O)N(C)c1ccccc1</td>\n      <td>5.619789</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nHowever, for a decision tree model, a few more molecular descriptors were probably needed rather than only IC50 or pIC50 and SMILES... One way to do this could be through computations based on canonical SMILES of compounds by using RDKit to add some molecular descriptors.\n\nBefore doing this, a compound sanitisation step would probably be the best before starting any calculations, as this might rule out some compounds with questionable chemical validities. This could also be done via RDKit or I guess Datamol (a Python wrapper library built based on RDKit) might also help as well.\n\nI thought to convert the data types of the \"smiles\" and \"data_validity_comment\" columns to string first (in case of running into problems later).\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n#df['column'].astype('string') \ndtree_df = dtree_df.astype({\"smiles\": \"string\", \"data_validity_comment\": \"string\"})\ndtree_df.dtypes\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nmolecule_chembl_id        object\nIC50                     float64\nunits                     object\ndata_validity_comment     string\nsmiles                    string\npIC50                    float64\ndtype: object\n```\n:::\n:::\n\n\nAlso, before I jumped straight to compound sanitisation, I thought I should check out if there were any comments in the \"data_validity_comment\" column.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndtree_df[\"data_validity_comment\"].unique()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n<StringArray>\n[<NA>, 'Outside typical range', 'Potential transcription error']\nLength: 3, dtype: string\n```\n:::\n:::\n\n\nInterestingly, there were 3 different types of data validity comments found, which were \"NaN\", \"Outside typical range\" and \"Potential transcirption error\". So, this meant we would need to address compounds with comments in the latter two.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# Find out number of compounds with \"outside typical range\" as data validity comment\ndtree_df[dtree_df[\"data_validity_comment\"] == \"Outside typical range\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n      <th>pIC50</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>19</th>\n      <td>CHEMBL46151</td>\n      <td>260000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>CCN(CC)CCS/C(=N\\O)C(=O)c1ccc(OC)cc1</td>\n      <td>3.585027</td>\n    </tr>\n    <tr>\n      <th>25</th>\n      <td>CHEMBL544022</td>\n      <td>520000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>CCN(CC)CCS/C(=N\\O)C(=O)c1ccc(Cl)cc1.Cl</td>\n      <td>3.283997</td>\n    </tr>\n    <tr>\n      <th>38</th>\n      <td>CHEMBL33051</td>\n      <td>460000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>NC(=O)c1cc[n+](COC[n+]2ccccc2/C=N/O)cc1.[Cl-]....</td>\n      <td>3.337242</td>\n    </tr>\n    <tr>\n      <th>41</th>\n      <td>CHEMBL543546</td>\n      <td>330000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>CC(C)N(CCS/C(=N\\O)C(=O)c1ccc(Cl)cc1)C(C)C.Cl</td>\n      <td>3.481486</td>\n    </tr>\n    <tr>\n      <th>42</th>\n      <td>CHEMBL1420</td>\n      <td>340000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>C[n+]1ccccc1C=NO</td>\n      <td>3.468521</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>4947</th>\n      <td>CHEMBL5190179</td>\n      <td>785000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>OCCCCCCCCc1ccc(CN2CCCCCC2)c(O)c1</td>\n      <td>3.105130</td>\n    </tr>\n    <tr>\n      <th>4995</th>\n      <td>CHEMBL1668934</td>\n      <td>115000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>CC(=O)N1CCC(NC(=O)Nc2ccc(OC(F)(F)F)cc2)CC1</td>\n      <td>3.939302</td>\n    </tr>\n    <tr>\n      <th>5025</th>\n      <td>CHEMBL5219232</td>\n      <td>1000000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>C#CCN[C@@H]1CCc2ccc(OC(=O)N(C)CC)cc21.C#CCN[C@...</td>\n      <td>3.000000</td>\n    </tr>\n    <tr>\n      <th>5027</th>\n      <td>CHEMBL1193656</td>\n      <td>150000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>C#CCNC1CCc2c(OC(=O)N(C)CC)cccc21</td>\n      <td>3.823909</td>\n    </tr>\n    <tr>\n      <th>5029</th>\n      <td>CHEMBL1193856</td>\n      <td>730000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>C#CCN(C)C1CCc2cccc(OC(=O)N(C)C)c21</td>\n      <td>3.136677</td>\n    </tr>\n  </tbody>\n</table>\n<p>328 rows × 6 columns</p>\n</div>\n```\n:::\n:::\n\n\nThere were a total of 328 compounds with IC50 outside typical range!\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# Find out number of compounds with \"potential transcription error\" as data validity comment\ndtree_df[dtree_df[\"data_validity_comment\"] == \"Potential transcription error\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n      <th>pIC50</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>753</th>\n      <td>CHEMBL189957</td>\n      <td>320.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CNC(=O)Oc1cccc(CN(C)CCCCCCCOc2ccc3c(=O)c4ccccc...</td>\n      <td>6.494850</td>\n    </tr>\n    <tr>\n      <th>755</th>\n      <td>CHEMBL190060</td>\n      <td>6860.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CNC(=O)Oc1cccc(CN(C)CCCOc2ccc3c(c2)O/C(=C\\c2cc...</td>\n      <td>5.163676</td>\n    </tr>\n    <tr>\n      <th>756</th>\n      <td>CHEMBL191386</td>\n      <td>3410.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CNC(=O)Oc1cccc(CN(C)CCCOc2ccc3c(c2)O/C(=C\\c2cc...</td>\n      <td>5.467246</td>\n    </tr>\n    <tr>\n      <th>761</th>\n      <td>CHEMBL370961</td>\n      <td>1950.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CNC(=O)Oc1cccc(CN(C)CCCCCCCOc2ccc3c(c2)O/C(=C\\...</td>\n      <td>5.709965</td>\n    </tr>\n    <tr>\n      <th>762</th>\n      <td>CHEMBL372710</td>\n      <td>8000.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CNC(=O)Oc1cccc(CN(C)CCCCCCCOc2ccc3c(c2)O/C(=C\\...</td>\n      <td>5.096910</td>\n    </tr>\n    <tr>\n      <th>763</th>\n      <td>CHEMBL364678</td>\n      <td>44600.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CNC(=O)Oc1cccc(CN(C)CCCCCCCOc2ccc3c(c2)O/C(=C\\...</td>\n      <td>4.350665</td>\n    </tr>\n    <tr>\n      <th>764</th>\n      <td>CHEMBL191461</td>\n      <td>1800.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CNC(=O)Oc1cccc(CN(C)CCCCCCCOc2ccc3c(c2)C/C(=C\\...</td>\n      <td>5.744727</td>\n    </tr>\n    <tr>\n      <th>1030</th>\n      <td>CHEMBL239046</td>\n      <td>7160.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CCN(Cc1ccccc1)Cc1ccc(-c2cc3cc(OCCNC(=O)/C=C/c4...</td>\n      <td>5.145087</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThere were 8 compounds with potential transcription errors for their respective IC50 values!\n\nThis meant it would be best to remove above compounds with questionable IC50 values (could be potential sources of errors for ML models later on). One of the ways I thought of doing was to fill the empty cells under \"data_validity_comment\" column, so this would be easier to filter.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# Fill \"NaN\" entries with an actual name e.g. zero\ndtree_df = dtree_df.fillna(\"zero\")\ndtree_df.head(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n      <th>pIC50</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL133897</td>\n      <td>750.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CCOc1nn(-c2cccc(OCc3ccccc3)c2)c(=O)o1</td>\n      <td>6.124939</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL336398</td>\n      <td>100.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC1CC1</td>\n      <td>7.000000</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL130628</td>\n      <td>300.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC(F)(F)F</td>\n      <td>6.522879</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL130478</td>\n      <td>800.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc(OC(F)(F)F)cc2)nn1C(=O)N(C)C</td>\n      <td>6.096910</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL130112</td>\n      <td>2400.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc(C)cc2)nn1C(=O)N(C)c1ccccc1</td>\n      <td>5.619789</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>CHEMBL130098</td>\n      <td>100.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc(Cl)cc2)nn1C(=O)N(C)C</td>\n      <td>7.000000</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>CHEMBL336538</td>\n      <td>800.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>COc1ccc(-c2nc(SC)n(C(=O)N(C)C)n2)cc1</td>\n      <td>6.096910</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>CHEMBL335033</td>\n      <td>50.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc3ccccc3c2)nn1C(=O)N(C)C</td>\n      <td>7.301030</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>CHEMBL338720</td>\n      <td>560.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc(-c3ccccc3)cc2)nn1C(=O)N(C)C</td>\n      <td>6.251812</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>CHEMBL131536</td>\n      <td>1400.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc(Cl)cc2)nn1C(=O)N(C)c1ccccc1</td>\n      <td>5.853872</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nFiltered out only the compounds with nil data validity comments.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n#dtree_df[\"data_validity_comment\"].unique()\ndtree_df = dtree_df[dtree_df[\"data_validity_comment\"] == \"zero\"]\n```\n:::\n\n\nChecking the dtree_df dataframe again and also whether if only the compounds with \"zero\" labelled for \"data_validity_comment\" column were kept (and other two types were removed).\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nprint(dtree_df.shape)\ndtree_df[\"data_validity_comment\"].unique()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(4703, 6)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n<StringArray>\n['zero']\nLength: 1, dtype: string\n```\n:::\n:::\n\n\n<br>\n\n#### **Compound sanitisation**\n\nI've found the [pre-processing molecules tutorial](https://docs.datamol.io/stable/tutorials/Preprocessing.html) and its reference links provided by Datamol at the bottom of the webpage to be very informative. Each steps of fix_mol(), sanitize_mol() and standardize_mol() were explained to a certain degree in the link provided above. I guess the key was to select pre-processing options required to fit the purpose of the ML models being built later on, and more experiences in doing this would also help to improve the compound pre-processing step.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# _preprocess function to sanitise compounds - adapted from datamol.io\n\nsmiles_column = \"smiles\"\n\ndm.disable_rdkit_log()\n\ndef _preprocess(row):\n    # Convert each compound to a RDKit molecule in the smiles column\n    mol = dm.to_mol(row[smiles_column], ordered=True)\n    # Fix common errors in the molecules\n    mol = dm.fix_mol(mol)\n    # Sanitise the molecules \n    mol = dm.sanitize_mol(mol, sanifix=True, charge_neutral=False)\n    # Standardise the molecules\n    mol = dm.standardize_mol(\n        mol,\n        disconnect_metals=False,\n        normalize=True,\n        reionize=True,\n        # Decided to switch on \"uncharge\" to neutralise charges - the only change\n        uncharge=True,\n        stereo=True,\n    )\n\n    # Added a new column below for RDKit molecules\n    row[\"rdkit_mol\"] = dm.to_mol(mol)\n    row[\"standard_smiles\"] = dm.standardize_smiles(dm.to_smiles(mol))\n    row[\"selfies\"] = dm.to_selfies(mol)\n    row[\"inchi\"] = dm.to_inchi(mol)\n    row[\"inchikey\"] = dm.to_inchikey(mol)\n    return row\n```\n:::\n\n\nThen the compound sanitisation function was applied to the dtree_df. \n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ndtree_san_df = dtree_df.apply(_preprocess, axis = 1)\ndtree_san_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n      <th>pIC50</th>\n      <th>rdkit_mol</th>\n      <th>standard_smiles</th>\n      <th>selfies</th>\n      <th>inchi</th>\n      <th>inchikey</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL133897</td>\n      <td>750.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CCOc1nn(-c2cccc(OCc3ccccc3)c2)c(=O)o1</td>\n      <td>6.124939</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x123eab5a0&gt;</td>\n      <td>CCOc1nn(-c2cccc(OCc3ccccc3)c2)c(=O)o1</td>\n      <td>[C][C][O][C][=N][N][Branch2][Ring1][Branch1][C...</td>\n      <td>InChI=1S/C17H16N2O4/c1-2-21-16-18-19(17(20)23-...</td>\n      <td>GUZKBNUSIOHJIR-UHFFFAOYSA-N</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL336398</td>\n      <td>100.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC1CC1</td>\n      <td>7.000000</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x123eab450&gt;</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC1CC1</td>\n      <td>[O][=C][Branch1][=Branch2][N][C][C][C][C][C][R...</td>\n      <td>InChI=1S/C18H21ClN4OS/c19-15-8-6-14(7-9-15)16-...</td>\n      <td>XWIIHZHUZCWNLW-UHFFFAOYSA-N</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL130628</td>\n      <td>300.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC(F)(F)F</td>\n      <td>6.522879</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x123eab4c0&gt;</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC(F)(F)F</td>\n      <td>[O][=C][Branch1][=Branch2][N][C][C][C][C][C][R...</td>\n      <td>InChI=1S/C16H16ClF3N4OS/c17-12-6-4-11(5-7-12)1...</td>\n      <td>GTBUYLWBDILEPY-UHFFFAOYSA-N</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL130478</td>\n      <td>800.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc(OC(F)(F)F)cc2)nn1C(=O)N(C)C</td>\n      <td>6.096910</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x123eaae30&gt;</td>\n      <td>CSc1nc(-c2ccc(OC(F)(F)F)cc2)nn1C(=O)N(C)C</td>\n      <td>[C][S][C][=N][C][Branch2][Ring1][Ring2][C][=C]...</td>\n      <td>InChI=1S/C13H13F3N4O2S/c1-19(2)12(21)20-11(23-...</td>\n      <td>FBOHEFQKBNWFPO-UHFFFAOYSA-N</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL130112</td>\n      <td>2400.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc(C)cc2)nn1C(=O)N(C)c1ccccc1</td>\n      <td>5.619789</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x123eaaea0&gt;</td>\n      <td>CSc1nc(-c2ccc(C)cc2)nn1C(=O)N(C)c1ccccc1</td>\n      <td>[C][S][C][=N][C][Branch1][N][C][=C][C][=C][Bra...</td>\n      <td>InChI=1S/C18H18N4OS/c1-13-9-11-14(12-10-13)16-...</td>\n      <td>AAXQEELWFXEVAH-UHFFFAOYSA-N</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nPlease note if the dataset required for sanitisation is large, Datamol has suggested using their example code to add parallelisation as shown below.\n\n```{{python}}\n# Code adapted from: https://docs.datamol.io/stable/tutorials/Preprocessing.html#references\ndata_clean = dm.parallelized(\n    _preprocess, \n    data.iterrows(), \n    arg_type=\"args\", \n    progress=True, \n    total=len(data)\n    )\ndata_clean = pd.DataFrame(data_clean)\n```\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndtree_san_df.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n(4703, 11)\n```\n:::\n:::\n\n\nIn this case, I tried using the preprocessing function without adding the parallelisation, the whole sanitisation process wasn't overly long, and was done within a minute or so (the dtree_df dataframe had 4,703 rows or compounds only).\n\n<br>\n\n#### **Detect outliers**\n\nPlotting a histogram to see the distribution of pIC50 values first.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ndtree_san_df.hist(column = \"pIC50\")\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\narray([[<AxesSubplot: title={'center': 'pIC50'}>]], dtype=object)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Data_prep_2_files/figure-html/cell-21-output-2.png){width=583 height=431}\n:::\n:::\n\n\nI read a bit about Dixon's Q test and realised that there were a few required assumptions prior to using this test, and the current dataset being used here (dtree_san_df) might not fit the requirements, which were: \n\n- normally distributed data \n- a small sample size e.g. between 3 and 10 (as originally stated in the paper published by R. B. Dean and W. J. Dixon (1951) Simplified Statistics for Small Numbers of Observations”. Anal. Chem., 1951, 23 (4), 636–638).\n\nSo I've decided that rather than showing Python code for Dixon's Q test myself, I'd attach a few examples from others instead, [Q test from Plotly](https://plotly.com/python/v3/outlier-test/) and also [Dixon's Q test for outlier identification – a questionable practice](https://sebastianraschka.com/Articles/2014_dixon_test.html), since this dataset here wasn't quite normally distributed as shown from the histogram plotted above. \n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\ndtree_san_df.boxplot(column = \"pIC50\")\n\n# the boxplot version below shows a blank background\n# rather than above version with horizontal grid lines\n#dtree_san_df.plot.box(column = \"pIC50\")\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n<AxesSubplot: >\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Data_prep_2_files/figure-html/cell-22-output-2.png){width=566 height=411}\n:::\n:::\n\n\nSo I used Pandas' built-in boxplot in addition to the histogram to show the likely outliers within the pIC50 values. Clearly, the possible outliers for pIC50 values appeared to be close to 10 and above. I've then decided not to completely remove these outliers due to the dataset itself being not in a Gaussian distribution (which meant they might not be true outliers).\n\n<br>\n\n#### **Molecular descriptors**\n\n",
    "supporting": [
      "Data_prep_2_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}