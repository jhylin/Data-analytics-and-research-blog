{
  "hash": "d83a83c7537c80152d5698de995b2a98",
  "result": {
    "markdown": "---\ntitle: Tree models in ChEMBL data\nsubtitle: ML series 2.1 - Decision tree - data pre-processing and preparation\ndraft: true\nformat: html\n---\n\n#### **Introduction**\n\nI've now come to a stage to do some more in-depth machine learning work after reading some peer-reviewed papers about it in relation to drug discovery and cheminformatics. Previously, I've only lightly touched on a commonly used classifier algorithm, logistic regression, as the first series in the machine learning realm. Reflecting back, I think I could've done a more thorough job during data preparation stage. So this would be attempted this time.\n\nFrom a few of the papers I've read so far, dated in the recent years of 2021 and 2022, it seemed that traditional machine learning (ML) methods were still indispensible performance-wise, and along with deep learning neural networks, they tend to increase prediction accuracy a bit more. I haven't ventured into the practicality and usefulness of large language models in drug discovery yet. From what I could gather from experienced seniors in this area, they were still very much too novel to be useful, and from what I could imagine, molecular representations in texts or strings probably had already created numerous headaches e.g. standardisations regarding to whether to use canonical SMILES and/or SELFIES or not, and probably compound chiralities and so on. Because of this, I'd be sticking with learning to walk first in the conventional ML area before trying to jog and run actually (plans to work on deep learning in the future).\n\nThe data preparation was carried out with strong reference to the materials and methods section in this paper: van Tilborg, D. *et al*. J. Chem. Inf.Model. 2022, 62, 5938-5951. There were probably other methods out there, but this was the paper I've read recently that had made sense and relatively easy to follow.\n\n<br>\n\n#### **Data retrieval**\n\nThis time I've decided to try something new which was to use the ChEMBL webresource client to get data from the scratch (i.e. not from direct file downloads from the ChEMBL website). I found this great online resource about fetching data this way here - reference: TeachOpenCADD talktorial on \\[compound data acquisition(https://projects.volkamerlab.org/teachopencadd/talktorials/T001_query_chembl.html)\\]. The data retrieval workflow used below was mainly adapted from this cited talktorial.\n\nThe webresource client was supported by ChEMBL group and based on a Django QuerySet interface - their [GitHub repository](https://github.com/chembl/chembl_webresource_client) might explain a bit more about it, particularly the Jupyter notebook provided in the repository would help a lot for how to write code to search for specific data.\n\nTo do this, a few libraries were needed first.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n!pip install --upgrade pip\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRequirement already satisfied: pip in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (23.2.1)\r\n```\n:::\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n%pip install chembl_webresource_client\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRequirement already satisfied: chembl_webresource_client in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (0.10.8)\r\nRequirement already satisfied: urllib3 in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (from chembl_webresource_client) (1.26.13)\r\nRequirement already satisfied: requests>=2.18.4 in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (from chembl_webresource_client) (2.28.1)\r\nRequirement already satisfied: requests-cache~=0.7.0 in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (from chembl_webresource_client) (0.7.5)\r\nRequirement already satisfied: easydict in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (from chembl_webresource_client) (1.10)\r\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nRequirement already satisfied: charset-normalizer<3,>=2 in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (from requests>=2.18.4->chembl_webresource_client) (2.1.1)\r\nRequirement already satisfied: idna<4,>=2.5 in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (from requests>=2.18.4->chembl_webresource_client) (3.4)\r\nRequirement already satisfied: certifi>=2017.4.17 in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (from requests>=2.18.4->chembl_webresource_client) (2022.12.7)\r\nRequirement already satisfied: attrs<22.0,>=21.2 in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (from requests-cache~=0.7.0->chembl_webresource_client) (21.4.0)\r\nRequirement already satisfied: itsdangerous>=2.0.1 in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (from requests-cache~=0.7.0->chembl_webresource_client) (2.1.2)\r\nRequirement already satisfied: pyyaml>=5.4 in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (from requests-cache~=0.7.0->chembl_webresource_client) (6.0.1)\r\nRequirement already satisfied: url-normalize<2.0,>=1.4 in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (from requests-cache~=0.7.0->chembl_webresource_client) (1.4.3)\r\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nRequirement already satisfied: six in /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages (from url-normalize<2.0,>=1.4->requests-cache~=0.7.0->chembl_webresource_client) (1.16.0)\r\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNote: you may need to restart the kernel to use updated packages.\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Import libraries\n# Fetch data through ChEMBL webresource client\nfrom chembl_webresource_client.new_client import new_client\n\n# RDKit modules\n#from rdkit.Chem import PandasTools\n\n# Dataframe library\n#import numpy as np\nimport pandas as pd\n\n# Progress bar\nfrom tqdm import tqdm\n```\n:::\n\n\nTo see what types of data were provided by ChEMBL webresource client, run the following code and refer to ChEMBL documentations to find out what data were embedded inside which data categories. Sometimes, it might not be that straight forward and some digging would be required (I went back to this step to find the \"data_validity_comment\" when I got to the compound sanitisation step actually).\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\navailable_resources = [resource for resource in dir(new_client) if not resource.startswith('_')]\nprint(available_resources)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['activity', 'activity_supplementary_data_by_activity', 'assay', 'assay_class', 'atc_class', 'binding_site', 'biotherapeutic', 'cell_line', 'chembl_id_lookup', 'compound_record', 'compound_structural_alert', 'description', 'document', 'document_similarity', 'drug', 'drug_indication', 'drug_warning', 'go_slim', 'image', 'mechanism', 'metabolism', 'molecule', 'molecule_form', 'official', 'organism', 'protein_classification', 'similarity', 'source', 'substructure', 'target', 'target_component', 'target_relation', 'tissue', 'xref_source']\n```\n:::\n:::\n\n\nCreate resource objects to enable API access as suggested.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# for targets (proteins)\ntargets_api = new_client.target\n\n# for bioactivities\nbioact_api = new_client.activity\n\n# for compounds\ncpd_api = new_client.molecule\n```\n:::\n\n\nCheck object type for one of these API objects (e.g. bioactivity API object).\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ntype(bioact_api)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nchembl_webresource_client.query_set.QuerySet\n```\n:::\n:::\n\n\n<br>\n\n##### **Fetching target data**\n\nSelect a protein target e.g. acetylcholinesterase (this was randomly chosen).\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Specify Uniprot ID for acetylcholinesterase\nuniprot_id = \"P22303\"\n\n# Get info from ChEMBL about this protein target, \n# with selected features only\ntargets = targets_api.get(target_components__accession = uniprot_id).only(\n    \"target_chembl_id\",\n    \"organism\", \n    \"pref_name\", \n    \"target_type\"\n)\n```\n:::\n\n\nThe query results were stored in a \"targets\" object, which was a QuerySet with lazy data evaluation only, meaning it would only react when there was a request for the data.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Read \"targets\" with Pandas\ntargets = pd.DataFrame.from_records(targets)\ntargets\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>organism</th>\n      <th>pref_name</th>\n      <th>target_chembl_id</th>\n      <th>target_type</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Homo sapiens</td>\n      <td>Acetylcholinesterase</td>\n      <td>CHEMBL220</td>\n      <td>SINGLE PROTEIN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Homo sapiens</td>\n      <td>Acetylcholinesterase</td>\n      <td>CHEMBL220</td>\n      <td>SINGLE PROTEIN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Homo sapiens</td>\n      <td>Cholinesterases; ACHE &amp; BCHE</td>\n      <td>CHEMBL2095233</td>\n      <td>SELECTIVITY GROUP</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nSelect protein target from this dataframe - choosing the first one.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Save the first protein in the dataframe\nselect_target = targets.iloc[0]\nselect_target\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\norganism                    Homo sapiens\npref_name           Acetylcholinesterase\ntarget_chembl_id               CHEMBL220\ntarget_type               SINGLE PROTEIN\nName: 0, dtype: object\n```\n:::\n:::\n\n\nSave the selected ChEMBL ID first (to be used later).\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nchembl_id = select_target.target_chembl_id\n# Check it's saved\nprint(chembl_id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCHEMBL220\n```\n:::\n:::\n\n\n<br>\n\n##### **Fetching bioactivity data**\n\nObtaining bioactivity data for the selected target.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nbioact = bioact_api.filter(\n    # Use the previously saved target ChEMBL ID\n    target_chembl_id = chembl_id, \n    # Bioactivity type\n    type = \"IC50\",\n    # Requesting exact measurements\n    relation = \"=\",\n    # Binding data as \"B\"\n    assay_type = \"B\"\n).only(\n    \"activity_id\",\n    \"data_validity_comment\"\n    \"assay_chembl_id\",\n    \"assay_description\",\n    \"assay_type\",\n    \"molecule_chembl_id\",\n    \"type\",\n    \"standard_units\",\n    \"relation\",\n    \"standard_value\",\n    \"target_chembl_id\",\n    \"target_organism\",\n)\n\n# Check the length and type of bioactivities object\nprint(len(bioact), type(bioact))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6129 <class 'chembl_webresource_client.query_set.QuerySet'>\n```\n:::\n:::\n\n\nTo have a quick look at the data being held inside each entry of the bioact dataset, e.g. for first entry.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nprint(len(bioact[0]), type(bioact[0]))\nbioact[0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n14 <class 'dict'>\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n{'activity_id': 33969,\n 'assay_chembl_id': 'CHEMBL643384',\n 'assay_description': 'Inhibitory concentration against acetylcholinesterase',\n 'assay_type': 'B',\n 'data_validity_comment': None,\n 'molecule_chembl_id': 'CHEMBL133897',\n 'relation': '=',\n 'standard_units': 'nM',\n 'standard_value': '750.0',\n 'target_chembl_id': 'CHEMBL220',\n 'target_organism': 'Homo sapiens',\n 'type': 'IC50',\n 'units': 'uM',\n 'value': '0.75'}\n```\n:::\n:::\n\n\nThe next step might take a few minutes - downloading the QuerySet as a Pandas DataFrame.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nbioact_df = pd.DataFrame.from_dict(bioact)\n\nbioact_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>activity_id</th>\n      <th>assay_chembl_id</th>\n      <th>assay_description</th>\n      <th>assay_type</th>\n      <th>data_validity_comment</th>\n      <th>molecule_chembl_id</th>\n      <th>relation</th>\n      <th>standard_units</th>\n      <th>standard_value</th>\n      <th>target_chembl_id</th>\n      <th>target_organism</th>\n      <th>type</th>\n      <th>units</th>\n      <th>value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>33969</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL133897</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>750.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n      <td>uM</td>\n      <td>0.75</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>37563</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL336398</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>100.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n      <td>uM</td>\n      <td>0.1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>38902</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL130628</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>300.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n      <td>uM</td>\n      <td>0.3</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>41170</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL130478</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>800.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n      <td>uM</td>\n      <td>0.8</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>42363</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL130112</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>2400.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n      <td>uM</td>\n      <td>2.4</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nCheck total rows and columns in the bioactivities dataframe.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nbioact_df.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n(6129, 14)\n```\n:::\n:::\n\n\n<br>\n\n###### **Pre-process bioactivity data**\n\nTo see a variety of units being recorded in the ChEMBL database - would need to be converted to nM.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nbioact_df[\"units\"].unique()\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\narray(['uM', 'mM', 'nM', 'M', 'ug ml-1', 'pM', \"10'-5M\", \"10'-3M\",\n       \"10'-2M\", \"10'-4M\", \"10'-7M\", \"10'-9M\", \"10'-6M\", \"10'-8M\",\n       \"10'-3microM\", \"10'-4microM\", 'uM/L', \"10'-10M\", 'umol', 'umol/L',\n       \"10'3pM\", \"10'6pM\", \"10'5pM\", \"10'2pM\", \"10'-12M\", \"10'-2microM\",\n       '10^-3microM', '10^-4microM', 'mg/ml', 'µM'], dtype=object)\n```\n:::\n:::\n\n\nThe simplest thing to do was to drop the \"units\" and \"value\" columns, which were in micromolar (*m*M), and to avoid unit conversion to nanomolar (nM), we could use columns such as \"standard_units\" and \"standard_value\" which were recorded with nM already.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nbioact_df.drop([\"units\", \"value\"], axis = 1, inplace = True)\n# Re-check df\nbioact_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>activity_id</th>\n      <th>assay_chembl_id</th>\n      <th>assay_description</th>\n      <th>assay_type</th>\n      <th>data_validity_comment</th>\n      <th>molecule_chembl_id</th>\n      <th>relation</th>\n      <th>standard_units</th>\n      <th>standard_value</th>\n      <th>target_chembl_id</th>\n      <th>target_organism</th>\n      <th>type</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>33969</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL133897</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>750.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>37563</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL336398</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>100.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>38902</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL130628</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>300.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>41170</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL130478</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>800.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>42363</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL130112</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>2400.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nbioact_df.dtypes\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nactivity_id               int64\nassay_chembl_id          object\nassay_description        object\nassay_type               object\ndata_validity_comment    object\nmolecule_chembl_id       object\nrelation                 object\nstandard_units           object\nstandard_value           object\ntarget_chembl_id         object\ntarget_organism          object\ntype                     object\ndtype: object\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# Small detour test\n# Tried with Polars - standard_value casted as \"str\", so would still need to convert to floats\n# import polars as pl\n# ba_df = pl.from_pandas(bioact_df)\n# ba_df.head()\n```\n:::\n\n\nConvert the column of \"standard_value\" from object to floats - so we could use this half maximal inhibitory concentration (IC50) values for calculations later.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nbioact_df = bioact_df.astype({\"standard_value\": \"float64\"})\n# Check column data types again\nbioact_df.dtypes\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\nactivity_id                int64\nassay_chembl_id           object\nassay_description         object\nassay_type                object\ndata_validity_comment     object\nmolecule_chembl_id        object\nrelation                  object\nstandard_units            object\nstandard_value           float64\ntarget_chembl_id          object\ntarget_organism           object\ntype                      object\ndtype: object\n```\n:::\n:::\n\n\nTaking care of any missing entries by removing them in the first place. I excluded \"data_validity_comment\" column in this exercise as this was required to check if there were any activity data of the compounds that were deemed to be not as valid e.g. excessively high IC50 value and so on. A lot of the compounds in this column probably had \"None\", which ensured that there were no particular alarm bells to the curated bioactivity data.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nbioact_df.dropna(subset = [\"activity_id\", \"assay_chembl_id\", \"assay_description\", \"assay_type\", \"molecule_chembl_id\", \"relation\", \"standard_units\", \"standard_value\", \"target_chembl_id\", \"target_organism\", \"type\"], axis = 0, how = \"any\", inplace = True)\n# Check number of rows and columns again (in this case, there appeared to be no change)\nbioact_df.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n(6129, 12)\n```\n:::\n:::\n\n\nSince all unique units inside the \"units\" and \"values\" columns were checked previously, I'd done the same for the \"standard_units\" column to see the ones recorded in it.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nbioact_df[\"standard_units\"].unique()\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\narray(['nM', 'ug.mL-1', \"10'3pM\", \"10'6pM\", \"10'5pM\", '10^-4microM', 'µM'],\n      dtype=object)\n```\n:::\n:::\n\n\nThere were a mixture of nM, mM and also picomolars (pM)!\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# Check for number of non-nM units\nbioact_df[bioact_df[\"standard_units\"] != \"nM\"].shape[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n30\n```\n:::\n:::\n\n\nThere appeared to be 30 non-nM values inside the fetched bioactivity data.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nbioact_df = bioact_df[bioact_df[\"standard_units\"] == \"nM\"]\n```\n:::\n\n\nThen narrow the results to only \"nM\" and check the dataframe again to see what units were left now.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# Check there were only nM\nbioact_df[\"standard_units\"].unique()\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\narray(['nM'], dtype=object)\n```\n:::\n:::\n\n\nSo the filtering worked and currently the number of rows and columns had been reduced.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n# Check df rows & columns\nbioact_df.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n(6099, 12)\n```\n:::\n:::\n\n\nNext part would be to remove all duplicates in the dataframe, especially when there were duplicate tests for the same compound.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nbioact_df.drop_duplicates(\"molecule_chembl_id\", keep = \"first\", inplace = True)\n```\n:::\n\n\nRenamed the \"standard_value\" and \"standard_units\" columns to be \"IC50\" and \"units\" respectively.\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nbioact_df.rename(\n    columns = {\n        \"standard_value\": \"IC50\",\n        \"standard_units\": \"units\"\n    }, inplace = True\n)\n\n# Check df to ensure name change\nbioact_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>activity_id</th>\n      <th>assay_chembl_id</th>\n      <th>assay_description</th>\n      <th>assay_type</th>\n      <th>data_validity_comment</th>\n      <th>molecule_chembl_id</th>\n      <th>relation</th>\n      <th>units</th>\n      <th>IC50</th>\n      <th>target_chembl_id</th>\n      <th>target_organism</th>\n      <th>type</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>33969</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL133897</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>750.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>37563</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL336398</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>100.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>38902</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL130628</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>300.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>41170</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL130478</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>800.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>42363</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL130112</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>2400.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nLastly, the index of the dataframe was reset.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nbioact_df.reset_index(drop = True, inplace = True)\nbioact_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>activity_id</th>\n      <th>assay_chembl_id</th>\n      <th>assay_description</th>\n      <th>assay_type</th>\n      <th>data_validity_comment</th>\n      <th>molecule_chembl_id</th>\n      <th>relation</th>\n      <th>units</th>\n      <th>IC50</th>\n      <th>target_chembl_id</th>\n      <th>target_organism</th>\n      <th>type</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>33969</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL133897</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>750.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>37563</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL336398</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>100.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>38902</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL130628</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>300.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>41170</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL130478</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>800.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>42363</td>\n      <td>CHEMBL643384</td>\n      <td>Inhibitory concentration against acetylcholine...</td>\n      <td>B</td>\n      <td>None</td>\n      <td>CHEMBL130112</td>\n      <td>=</td>\n      <td>nM</td>\n      <td>2400.0</td>\n      <td>CHEMBL220</td>\n      <td>Homo sapiens</td>\n      <td>IC50</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nOne final check on the number of columns and rows after pre-processing the bioactivity dataframe.\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nbioact_df.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n(5041, 12)\n```\n:::\n:::\n\n\nThere were a total of 11 columns with 5,041 rows of data left in the bioactivity dataframe.\n\n<br>\n\n##### **Fetching compound data**\n\nWhile having identified the protein target and obtained the bioactivity data, this step was to link the bioactivity data to the compounds.\n\nThis could be done by having the ChEMBL IDs available for the compounds involved in the bioactivity dataset.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\ncpds = cpd_api.filter(\n    molecule_chembl_id__in = list(bioact_df[\"molecule_chembl_id\"])\n).only(\n    \"molecule_chembl_id\",\n    \"molecule_structures\"\n)\n```\n:::\n\n\nHere, the same step was applied where the compound QuerySet object was converted into a Pandas dataframe. However, the dataset extracted this time could take longer than the time taken to fetch the bioactivity data. This was then monitored using a progress bar (tqdm package).\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\ncompds = list(tqdm(cpds))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\r  0%|          | 0/5041 [00:00<?, ?it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r  6%|▌         | 281/5041 [00:00<00:01, 2581.21it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 11%|█         | 540/5041 [00:00<00:01, 2363.48it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 15%|█▌        | 777/5041 [00:00<00:01, 2214.36it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 20%|█▉        | 999/5041 [00:00<00:01, 2132.60it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 24%|██▍       | 1213/5041 [00:00<00:01, 2111.42it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 28%|██▊       | 1425/5041 [00:00<00:01, 2056.73it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 33%|███▎      | 1641/5041 [00:00<00:01, 2040.92it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 37%|███▋      | 1846/5041 [00:00<00:01, 1999.89it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 41%|████      | 2061/5041 [00:00<00:01, 2026.07it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 45%|████▍     | 2264/5041 [00:01<00:01, 2025.11it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 50%|█████     | 2521/5041 [00:01<00:01, 2147.95it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 55%|█████▌    | 2781/5041 [00:01<00:00, 2274.07it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 60%|█████▉    | 3009/5041 [00:01<00:00, 2266.79it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 64%|██████▍   | 3236/5041 [00:01<00:00, 2264.18it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 69%|██████▊   | 3463/5041 [00:01<00:00, 2235.08it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 73%|███████▎  | 3687/5041 [00:01<00:00, 2188.45it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 78%|███████▊  | 3907/5041 [00:01<00:00, 2136.69it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 82%|████████▏ | 4121/5041 [00:01<00:00, 2053.05it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 86%|████████▌ | 4341/5041 [00:02<00:00, 2074.41it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 90%|█████████ | 4561/5041 [00:02<00:00, 2057.47it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r 95%|█████████▌| 4801/5041 [00:02<00:00, 2124.59it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r100%|█████████▉| 5021/5041 [00:02<00:00, 2138.49it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\r100%|██████████| 5041/5041 [00:02<00:00, 2140.16it/s]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n:::\n\n\nConverting retrieved compound QuerySet into a Pandas DataFrame.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\ncpds_df = pd.DataFrame.from_records(compds)\n\nprint(cpds_df.shape)\ncpds_df.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(5041, 2)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=32}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>molecule_structures</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL411</td>\n      <td>{'canonical_smiles': 'CC/C(=C(/CC)c1ccc(O)cc1)...</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL416</td>\n      <td>{'canonical_smiles': 'COc1c2occc2cc2ccc(=O)oc1...</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL21</td>\n      <td>{'canonical_smiles': 'Nc1ccc(S(N)(=O)=O)cc1', ...</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL424</td>\n      <td>{'canonical_smiles': 'O=C(O)c1ccccc1O', 'molfi...</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL7002</td>\n      <td>{'canonical_smiles': 'CC1(COc2ccc(CC3SC(=O)NC3...</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\n###### **Pre-process compound data**\n\nRemoving any missing entries in the compound data.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\ncpds_df.dropna(axis = 0, how = \"any\", inplace = True)\n\n# Check columns & rows in df\ncpds_df.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n(5040, 2)\n```\n:::\n:::\n\n\nRemoving any duplicates in the compound data.\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\ncpds_df.drop_duplicates(\"molecule_chembl_id\", keep = \"first\", inplace = True)\n\n# Check columns & rows again\ncpds_df.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n(5040, 2)\n```\n:::\n:::\n\n\nIdeally, only the compounds with canonical SMILES would be kept. Checking for the types of molecular representations used in the \"molecule_structures\" column of the compound dataset.\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# Randomly choosing the 2nd entry\ncpds_df.iloc[1].molecule_structures.keys()\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\ndict_keys(['canonical_smiles', 'molfile', 'standard_inchi', 'standard_inchi_key'])\n```\n:::\n:::\n\n\nThere were 4 types as: \"canonical_smiles\", \"molfile\", \"standard_inchi\" and \"standard_inchi_key\".\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Create an empty list to store the canonical smiles\ncan_smiles = []\n\n# Create a for loop to loop over each row of data, \n# searching for only canonical_smiles to append to the created list\nfor i, cpd in cpds_df.iterrows():\n    try:\n        can_smiles.append(cpd[\"molecule_structures\"][\"canonical_smiles\"])\n    except KeyError:\n        can_smiles.append(None)\n\n# Create a new df column with name as \"smiles\", \n# which will store all the canonical smiles collected from the list above\ncpds_df[\"smiles\"] = can_smiles\n```\n:::\n\n\nCheck the compound dataframe quickly to see if a new column for SMILES has been created.\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\ncpds_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>molecule_structures</th>\n      <th>smiles</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL411</td>\n      <td>{'canonical_smiles': 'CC/C(=C(/CC)c1ccc(O)cc1)...</td>\n      <td>CC/C(=C(/CC)c1ccc(O)cc1)c1ccc(O)cc1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL416</td>\n      <td>{'canonical_smiles': 'COc1c2occc2cc2ccc(=O)oc1...</td>\n      <td>COc1c2occc2cc2ccc(=O)oc12</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL21</td>\n      <td>{'canonical_smiles': 'Nc1ccc(S(N)(=O)=O)cc1', ...</td>\n      <td>Nc1ccc(S(N)(=O)=O)cc1</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL424</td>\n      <td>{'canonical_smiles': 'O=C(O)c1ccccc1O', 'molfi...</td>\n      <td>O=C(O)c1ccccc1O</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL7002</td>\n      <td>{'canonical_smiles': 'CC1(COc2ccc(CC3SC(=O)NC3...</td>\n      <td>CC1(COc2ccc(CC3SC(=O)NC3=O)cc2)CCCCC1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nOnce confirmed, the old \"molecule_structures\" column was then removed.\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\ncpds_df.drop(\"molecule_structures\", axis = 1, inplace = True)\n```\n:::\n\n\nFinally, adding another step to ensure all missing entries or entries without canonical SMILES strings were removed from the compound dataset.\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\ncpds_df.dropna(axis = 0, how = \"any\", inplace = True)\n\nprint(cpds_df.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(5040, 2)\n```\n:::\n:::\n\n\nFinal look at the compound dataset, which should only include compounds ChEMBL IDs and SMILES columns.\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\ncpds_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>smiles</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL411</td>\n      <td>CC/C(=C(/CC)c1ccc(O)cc1)c1ccc(O)cc1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL416</td>\n      <td>COc1c2occc2cc2ccc(=O)oc12</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL21</td>\n      <td>Nc1ccc(S(N)(=O)=O)cc1</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL424</td>\n      <td>O=C(O)c1ccccc1O</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL7002</td>\n      <td>CC1(COc2ccc(CC3SC(=O)NC3=O)cc2)CCCCC1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n<br>\n\n##### **Combining bioactivity and compound data**\n\nTo combine both datasets, the key was to look for common column (similar to a SQL \"join\" query) between the two datasets.\n\nListing all the column names for both datasets would show the common column.\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\nbioact_df.columns\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\nIndex(['activity_id', 'assay_chembl_id', 'assay_description', 'assay_type',\n       'data_validity_comment', 'molecule_chembl_id', 'relation', 'units',\n       'IC50', 'target_chembl_id', 'target_organism', 'type'],\n      dtype='object')\n```\n:::\n:::\n\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\ncpds_df.columns\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\nIndex(['molecule_chembl_id', 'smiles'], dtype='object')\n```\n:::\n:::\n\n\nClearly, the one column that existed in both dataframes was the \"molecule_chembl_id\" column.\n\nThe next step was to combine or merge both datasets.\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n# Create a final dataframe that will contain both bioactivity and compound data\ndtree_df = pd.merge(\n    bioact_df[[\"molecule_chembl_id\", \"IC50\", \"units\", \"data_validity_comment\"]],\n    cpds_df,\n    on = \"molecule_chembl_id\",\n)\n\ndtree_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL133897</td>\n      <td>750.0</td>\n      <td>nM</td>\n      <td>None</td>\n      <td>CCOc1nn(-c2cccc(OCc3ccccc3)c2)c(=O)o1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL336398</td>\n      <td>100.0</td>\n      <td>nM</td>\n      <td>None</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC1CC1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL130628</td>\n      <td>300.0</td>\n      <td>nM</td>\n      <td>None</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC(F)(F)F</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL130478</td>\n      <td>800.0</td>\n      <td>nM</td>\n      <td>None</td>\n      <td>CSc1nc(-c2ccc(OC(F)(F)F)cc2)nn1C(=O)N(C)C</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL130112</td>\n      <td>2400.0</td>\n      <td>nM</td>\n      <td>None</td>\n      <td>CSc1nc(-c2ccc(C)cc2)nn1C(=O)N(C)c1ccccc1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nRow indices were reset and shape of the final dataframe was checked.\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\ndtree_df.reset_index(drop = True, inplace = True)\n\nprint(dtree_df.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(5040, 5)\n```\n:::\n:::\n\n\nSaving a copy of the merged dataframe for now (to avoid re-running the previous code repeatedly).\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\ndtree_df.to_csv(\"ache_chembl.csv\")\n```\n:::\n\n\n<br>\n\n##### **Re-import saved dataframe**\n\nRe-import partly pre-processed dtree_df.\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\ndtree_df = pd.read_csv(\"ache_chembl.csv\")\ndtree_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Unnamed: 0</th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>CHEMBL133897</td>\n      <td>750.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CCOc1nn(-c2cccc(OCc3ccccc3)c2)c(=O)o1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1</td>\n      <td>CHEMBL336398</td>\n      <td>100.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC1CC1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2</td>\n      <td>CHEMBL130628</td>\n      <td>300.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC(F)(F)F</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>3</td>\n      <td>CHEMBL130478</td>\n      <td>800.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CSc1nc(-c2ccc(OC(F)(F)F)cc2)nn1C(=O)N(C)C</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>4</td>\n      <td>CHEMBL130112</td>\n      <td>2400.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CSc1nc(-c2ccc(C)cc2)nn1C(=O)N(C)c1ccccc1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNoticed there was an extra index column, likely inherited from how the .csv file was saved, which was subsequently removed.\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\ndtree_df = dtree_df.drop(\"Unnamed: 0\", axis = 1)\ndtree_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL133897</td>\n      <td>750.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CCOc1nn(-c2cccc(OCc3ccccc3)c2)c(=O)o1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL336398</td>\n      <td>100.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC1CC1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL130628</td>\n      <td>300.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC(F)(F)F</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL130478</td>\n      <td>800.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CSc1nc(-c2ccc(OC(F)(F)F)cc2)nn1C(=O)N(C)C</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL130112</td>\n      <td>2400.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CSc1nc(-c2ccc(C)cc2)nn1C(=O)N(C)c1ccccc1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe merged dataframe was found to have IC50 with zero nM, which meant the function to convert IC50 to pIC50 would not proceed (due to natural log of zero normally means undefined answer!). So a good practice to clean data like this was probably best to run a statistical summary such as the code below first, then look for minimum and maximum values and also others to see if there were anything to be tidied up first.\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\ndtree_df.describe()\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>IC50</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>count</th>\n      <td>5.040000e+03</td>\n    </tr>\n    <tr>\n      <th>mean</th>\n      <td>8.070638e+04</td>\n    </tr>\n    <tr>\n      <th>std</th>\n      <td>9.511451e+05</td>\n    </tr>\n    <tr>\n      <th>min</th>\n      <td>0.000000e+00</td>\n    </tr>\n    <tr>\n      <th>25%</th>\n      <td>1.000000e+02</td>\n    </tr>\n    <tr>\n      <th>50%</th>\n      <td>1.200000e+03</td>\n    </tr>\n    <tr>\n      <th>75%</th>\n      <td>9.700000e+03</td>\n    </tr>\n    <tr>\n      <th>max</th>\n      <td>4.960000e+07</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nLimiting the IC50 values to be above zero only.\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\n# Select IC50 values above zero\ndtree_df = dtree_df[dtree_df[\"IC50\"] > 0.0]\n```\n:::\n\n\nRe-checked the minimum value of IC50 column, which should be above zero.\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\ndtree_df[\"IC50\"].min()\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\n5e-06\n```\n:::\n:::\n\n\nNow we could convert the IC50 values to pIC50 values (the negative log of IC50 in molar units).\n\nThe key to understand pIC50 here was to treat pIC50 similarly to how we understand pH for our acids and bases. pIC50 was a dimensionless value (so no units actually!) - *useful link*. The formula to convert IC50 to pIC50 for nM units was (**use LaTex for formula**):\n\npIC50 = 9 - log10(IC50)\n\nImport the math library first and set up a small function to do the conversion.\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\nimport math\n\ndef calc_pIC50(IC50):\n    pIC50_value = 9 - math.log10(IC50)\n    return pIC50_value\n```\n:::\n\n\nApplying the calc_pIC50 function to convert all rows of the compound dataset for the IC50 column.\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\n# Create a new column for pIC50\n# Apply calc_pIC50 function to the data in IC50 column\ndtree_df[\"pIC50\"] = dtree_df.apply(lambda x: calc_pIC50(x.IC50), axis = 1)\n```\n:::\n\n\nThe dataframe would now look like this, with a new pIC50 column ready for use.\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\ndtree_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=53}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n      <th>pIC50</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL133897</td>\n      <td>750.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CCOc1nn(-c2cccc(OCc3ccccc3)c2)c(=O)o1</td>\n      <td>6.124939</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL336398</td>\n      <td>100.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC1CC1</td>\n      <td>7.000000</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL130628</td>\n      <td>300.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC(F)(F)F</td>\n      <td>6.522879</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL130478</td>\n      <td>800.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CSc1nc(-c2ccc(OC(F)(F)F)cc2)nn1C(=O)N(C)C</td>\n      <td>6.096910</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL130112</td>\n      <td>2400.0</td>\n      <td>nM</td>\n      <td>NaN</td>\n      <td>CSc1nc(-c2ccc(C)cc2)nn1C(=O)N(C)c1ccccc1</td>\n      <td>5.619789</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nHowever, for a decision tree model, a few more molecular descriptors were probably needed rather than only IC50 or pIC50 and SMILES... One way to do this could be through computations based on canonical SMILES of compounds by using RDKit to add some molecular descriptors.\n\nBefore doing this, a compound sanitisation step would probably be the best before starting any calculations, as this might rule out some compounds with questionable chemical validities. This could also be done via RDKit or I guess Datamol (a Python wrapper library built based on RDKit) might also help as well.\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\n#df['column'].astype('string') \ndtree_df = dtree_df.astype({\"smiles\": \"string\", \"data_validity_comment\": \"string\"})\ndtree_df.dtypes\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\nmolecule_chembl_id        object\nIC50                     float64\nunits                     object\ndata_validity_comment     string\nsmiles                    string\npIC50                    float64\ndtype: object\n```\n:::\n:::\n\n\nBefore I jumped straight to compound sanitisation, I thought I should check out if there were any variations in the \"data_validity_comment\" column.\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\ndtree_df[\"data_validity_comment\"].unique()\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\n<StringArray>\n[<NA>, 'Outside typical range', 'Potential transcription error']\nLength: 3, dtype: string\n```\n:::\n:::\n\n\nInterestingly, there were 3 different types of data validity comments found, which were \"NaN\", \"Outside typical range\" and \"Potential transcirption error\". So, this meant we would need to address compounds with comments in the latter two.\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\n# Find out number of compounds with \"outside typical range\" as data validity comment\ndtree_df[dtree_df[\"data_validity_comment\"] == \"Outside typical range\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=56}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n      <th>pIC50</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>19</th>\n      <td>CHEMBL46151</td>\n      <td>260000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>CCN(CC)CCS/C(=N\\O)C(=O)c1ccc(OC)cc1</td>\n      <td>3.585027</td>\n    </tr>\n    <tr>\n      <th>25</th>\n      <td>CHEMBL544022</td>\n      <td>520000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>CCN(CC)CCS/C(=N\\O)C(=O)c1ccc(Cl)cc1.Cl</td>\n      <td>3.283997</td>\n    </tr>\n    <tr>\n      <th>38</th>\n      <td>CHEMBL33051</td>\n      <td>460000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>NC(=O)c1cc[n+](COC[n+]2ccccc2/C=N/O)cc1.[Cl-]....</td>\n      <td>3.337242</td>\n    </tr>\n    <tr>\n      <th>41</th>\n      <td>CHEMBL543546</td>\n      <td>330000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>CC(C)N(CCS/C(=N\\O)C(=O)c1ccc(Cl)cc1)C(C)C.Cl</td>\n      <td>3.481486</td>\n    </tr>\n    <tr>\n      <th>42</th>\n      <td>CHEMBL1420</td>\n      <td>340000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>C[n+]1ccccc1C=NO</td>\n      <td>3.468521</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>4947</th>\n      <td>CHEMBL5190179</td>\n      <td>785000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>OCCCCCCCCc1ccc(CN2CCCCCC2)c(O)c1</td>\n      <td>3.105130</td>\n    </tr>\n    <tr>\n      <th>4995</th>\n      <td>CHEMBL1668934</td>\n      <td>115000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>CC(=O)N1CCC(NC(=O)Nc2ccc(OC(F)(F)F)cc2)CC1</td>\n      <td>3.939302</td>\n    </tr>\n    <tr>\n      <th>5025</th>\n      <td>CHEMBL5219232</td>\n      <td>1000000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>C#CCN[C@@H]1CCc2ccc(OC(=O)N(C)CC)cc21.C#CCN[C@...</td>\n      <td>3.000000</td>\n    </tr>\n    <tr>\n      <th>5027</th>\n      <td>CHEMBL1193656</td>\n      <td>150000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>C#CCNC1CCc2c(OC(=O)N(C)CC)cccc21</td>\n      <td>3.823909</td>\n    </tr>\n    <tr>\n      <th>5029</th>\n      <td>CHEMBL1193856</td>\n      <td>730000.0</td>\n      <td>nM</td>\n      <td>Outside typical range</td>\n      <td>C#CCN(C)C1CCc2cccc(OC(=O)N(C)C)c21</td>\n      <td>3.136677</td>\n    </tr>\n  </tbody>\n</table>\n<p>328 rows × 6 columns</p>\n</div>\n```\n:::\n:::\n\n\nThere were a total of 328 compounds with IC50 outside typical range!\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\n# Find out number of compounds with \"potential transcription error\" as data validity comment\ndtree_df[dtree_df[\"data_validity_comment\"] == \"Potential transcription error\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=57}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n      <th>pIC50</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>753</th>\n      <td>CHEMBL189957</td>\n      <td>320.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CNC(=O)Oc1cccc(CN(C)CCCCCCCOc2ccc3c(=O)c4ccccc...</td>\n      <td>6.494850</td>\n    </tr>\n    <tr>\n      <th>755</th>\n      <td>CHEMBL190060</td>\n      <td>6860.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CNC(=O)Oc1cccc(CN(C)CCCOc2ccc3c(c2)O/C(=C\\c2cc...</td>\n      <td>5.163676</td>\n    </tr>\n    <tr>\n      <th>756</th>\n      <td>CHEMBL191386</td>\n      <td>3410.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CNC(=O)Oc1cccc(CN(C)CCCOc2ccc3c(c2)O/C(=C\\c2cc...</td>\n      <td>5.467246</td>\n    </tr>\n    <tr>\n      <th>761</th>\n      <td>CHEMBL370961</td>\n      <td>1950.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CNC(=O)Oc1cccc(CN(C)CCCCCCCOc2ccc3c(c2)O/C(=C\\...</td>\n      <td>5.709965</td>\n    </tr>\n    <tr>\n      <th>762</th>\n      <td>CHEMBL372710</td>\n      <td>8000.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CNC(=O)Oc1cccc(CN(C)CCCCCCCOc2ccc3c(c2)O/C(=C\\...</td>\n      <td>5.096910</td>\n    </tr>\n    <tr>\n      <th>763</th>\n      <td>CHEMBL364678</td>\n      <td>44600.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CNC(=O)Oc1cccc(CN(C)CCCCCCCOc2ccc3c(c2)O/C(=C\\...</td>\n      <td>4.350665</td>\n    </tr>\n    <tr>\n      <th>764</th>\n      <td>CHEMBL191461</td>\n      <td>1800.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CNC(=O)Oc1cccc(CN(C)CCCCCCCOc2ccc3c(c2)C/C(=C\\...</td>\n      <td>5.744727</td>\n    </tr>\n    <tr>\n      <th>1030</th>\n      <td>CHEMBL239046</td>\n      <td>7160.0</td>\n      <td>nM</td>\n      <td>Potential transcription error</td>\n      <td>CCN(Cc1ccccc1)Cc1ccc(-c2cc3cc(OCCNC(=O)/C=C/c4...</td>\n      <td>5.145087</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThere were 8 compounds with potential transcription errors for their respective IC50 values!\n\nThis meant it would be best to remove above compounds with questionable IC50 values (could be potential sources of errors for ML models later on). One of the ways I thought of doing was to fill the empty cells under \"data_validity_comment\" column, so this would be easier to filter.\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\n# Fill \"NaN\" entries with an actual name e.g. zero\ndtree_df = dtree_df.fillna(\"zero\")\ndtree_df.head(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=58}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n      <th>pIC50</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL133897</td>\n      <td>750.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CCOc1nn(-c2cccc(OCc3ccccc3)c2)c(=O)o1</td>\n      <td>6.124939</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL336398</td>\n      <td>100.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC1CC1</td>\n      <td>7.000000</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL130628</td>\n      <td>300.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC(F)(F)F</td>\n      <td>6.522879</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL130478</td>\n      <td>800.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc(OC(F)(F)F)cc2)nn1C(=O)N(C)C</td>\n      <td>6.096910</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL130112</td>\n      <td>2400.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc(C)cc2)nn1C(=O)N(C)c1ccccc1</td>\n      <td>5.619789</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>CHEMBL130098</td>\n      <td>100.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc(Cl)cc2)nn1C(=O)N(C)C</td>\n      <td>7.000000</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>CHEMBL336538</td>\n      <td>800.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>COc1ccc(-c2nc(SC)n(C(=O)N(C)C)n2)cc1</td>\n      <td>6.096910</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>CHEMBL335033</td>\n      <td>50.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc3ccccc3c2)nn1C(=O)N(C)C</td>\n      <td>7.301030</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>CHEMBL338720</td>\n      <td>560.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc(-c3ccccc3)cc2)nn1C(=O)N(C)C</td>\n      <td>6.251812</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>CHEMBL131536</td>\n      <td>1400.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc(Cl)cc2)nn1C(=O)N(C)c1ccccc1</td>\n      <td>5.853872</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nFiltered out only the compounds with nil data validity comments.\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\n#dtree_df[\"data_validity_comment\"].unique()\ndtree_df = dtree_df[dtree_df[\"data_validity_comment\"] == \"zero\"]\n```\n:::\n\n\nChecking the dtree_df dataframe again and also whether if only the compounds with \"zero\" labelled for \"data_validity_comment\" column were kept (and other two types were removed).\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\nprint(dtree_df.shape)\ndtree_df[\"data_validity_comment\"].unique()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(4703, 6)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=60}\n```\n<StringArray>\n['zero']\nLength: 1, dtype: string\n```\n:::\n:::\n\n\n<br>\n\n#### **Compound sanitisation**\n\nI've found the [pre-processing molecules tutorial](https://docs.datamol.io/stable/tutorials/Preprocessing.html) and its reference links provided provided by Datamol at the bottom of the webpage to be very informative. Each steps of fix_mol(), sanitize_mol() and standardize_mol() were explained to a certain degree in the link provided above. I guess the key was to select preprocessing options required to fit the purpose of the ML model being built later on, and experiences would also help to improve the compound preprocessing step.\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\nimport datamol as dm\n\n# _preprocess function to sanitise compounds - adapted from datamol.io\n\nsmiles_column = \"smiles\"\n\ndm.disable_rdkit_log()\n\ndef _preprocess(row):\n    # Convert each compound to a RDKit molecule in the smiles column\n    mol = dm.to_mol(row[smiles_column], ordered=True)\n    # Fix common errors in the molecules\n    mol = dm.fix_mol(mol)\n    # Sanitise the molecules \n    mol = dm.sanitize_mol(mol, sanifix=True, charge_neutral=False)\n    # Standardise the molecules\n    mol = dm.standardize_mol(\n        mol,\n        disconnect_metals=False,\n        normalize=True,\n        reionize=True,\n        # Decided to switch on \"uncharge\" to neutralise charges - the only change\n        uncharge=True,\n        stereo=True,\n    )\n\n    # Added a new column below for RDKit molecules\n    row[\"rdkit_mol\"] = dm.to_mol(mol)\n    row[\"standard_smiles\"] = dm.standardize_smiles(dm.to_smiles(mol))\n    row[\"selfies\"] = dm.to_selfies(mol)\n    row[\"inchi\"] = dm.to_inchi(mol)\n    row[\"inchikey\"] = dm.to_inchikey(mol)\n    return row\n```\n:::\n\n\nThen the compound sanitisation function was applied to the dtree_df.\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\ndtree_san_df = dtree_df.apply(_preprocess, axis = 1)\ndtree_san_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=62}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>molecule_chembl_id</th>\n      <th>IC50</th>\n      <th>units</th>\n      <th>data_validity_comment</th>\n      <th>smiles</th>\n      <th>pIC50</th>\n      <th>rdkit_mol</th>\n      <th>standard_smiles</th>\n      <th>selfies</th>\n      <th>inchi</th>\n      <th>inchikey</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CHEMBL133897</td>\n      <td>750.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CCOc1nn(-c2cccc(OCc3ccccc3)c2)c(=O)o1</td>\n      <td>6.124939</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x12a44b680&gt;</td>\n      <td>CCOc1nn(-c2cccc(OCc3ccccc3)c2)c(=O)o1</td>\n      <td>[C][C][O][C][=N][N][Branch2][Ring1][Branch1][C...</td>\n      <td>InChI=1S/C17H16N2O4/c1-2-21-16-18-19(17(20)23-...</td>\n      <td>GUZKBNUSIOHJIR-UHFFFAOYSA-N</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CHEMBL336398</td>\n      <td>100.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC1CC1</td>\n      <td>7.000000</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x12a44be60&gt;</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC1CC1</td>\n      <td>[O][=C][Branch1][=Branch2][N][C][C][C][C][C][R...</td>\n      <td>InChI=1S/C18H21ClN4OS/c19-15-8-6-14(7-9-15)16-...</td>\n      <td>XWIIHZHUZCWNLW-UHFFFAOYSA-N</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CHEMBL130628</td>\n      <td>300.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC(F)(F)F</td>\n      <td>6.522879</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x12a44b5a0&gt;</td>\n      <td>O=C(N1CCCCC1)n1nc(-c2ccc(Cl)cc2)nc1SCC(F)(F)F</td>\n      <td>[O][=C][Branch1][=Branch2][N][C][C][C][C][C][R...</td>\n      <td>InChI=1S/C16H16ClF3N4OS/c17-12-6-4-11(5-7-12)1...</td>\n      <td>GTBUYLWBDILEPY-UHFFFAOYSA-N</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CHEMBL130478</td>\n      <td>800.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc(OC(F)(F)F)cc2)nn1C(=O)N(C)C</td>\n      <td>6.096910</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x12a44b840&gt;</td>\n      <td>CSc1nc(-c2ccc(OC(F)(F)F)cc2)nn1C(=O)N(C)C</td>\n      <td>[C][S][C][=N][C][Branch2][Ring1][Ring2][C][=C]...</td>\n      <td>InChI=1S/C13H13F3N4O2S/c1-19(2)12(21)20-11(23-...</td>\n      <td>FBOHEFQKBNWFPO-UHFFFAOYSA-N</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CHEMBL130112</td>\n      <td>2400.0</td>\n      <td>nM</td>\n      <td>zero</td>\n      <td>CSc1nc(-c2ccc(C)cc2)nn1C(=O)N(C)c1ccccc1</td>\n      <td>5.619789</td>\n      <td>&lt;rdkit.Chem.rdchem.Mol object at 0x12a44b8b0&gt;</td>\n      <td>CSc1nc(-c2ccc(C)cc2)nn1C(=O)N(C)c1ccccc1</td>\n      <td>[C][S][C][=N][C][Branch1][N][C][=C][C][=C][Bra...</td>\n      <td>InChI=1S/C18H18N4OS/c1-13-9-11-14(12-10-13)16-...</td>\n      <td>AAXQEELWFXEVAH-UHFFFAOYSA-N</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nPlease note if the dataset required for sanitisation is large, Datamol has suggested using their example code to add parallelisation as shown below.\n\n``` {{python}}\n# Code adapted from: https://docs.datamol.io/stable/tutorials/Preprocessing.html#references\ndata_clean = dm.parallelized(\n    _preprocess, \n    data.iterrows(), \n    arg_type=\"args\", \n    progress=True, \n    total=len(data)\n    )\ndata_clean = pd.DataFrame(data_clean)\n```\n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\ndtree_san_df.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=63}\n```\n(4703, 11)\n```\n:::\n:::\n\n\nIn this case, I tried using the preprocessing function without adding the parallelisation, the whole sanitisation process wasn't overly long, and was done within a minute or so (the dtree_df dataframe had 4,703 rows or compounds only).\n\n<br>\n\n#### **Detect outliers**\n\nPlotting a histogram to see the distribution of pIC50 values first.\n\n::: {.cell execution_count=64}\n``` {.python .cell-code}\ndtree_san_df.hist(column = \"pIC50\")\n```\n\n::: {.cell-output .cell-output-display execution_count=64}\n```\narray([[<AxesSubplot: title={'center': 'pIC50'}>]], dtype=object)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Data_prep_files/figure-html/cell-65-output-2.png){width=583 height=431}\n:::\n:::\n\n\nI read a bit about Dixon's Q test and realised that there were a few required assumptions prior to using this test, and the current dataset being used here (dtree_san_df) might not fit the requirements, which were:\n\n-   normally distributed data\n-   a small sample size i.e. e.g. between 3 and 10 (as originally stated in the paper published by R. B. Dean and W. J. Dixon (1951) Simplified Statistics for Small Numbers of Observations\". Anal. Chem., 1951, 23 (4), 636--638).\n\nSo I've decided that rather than showing Python code for Dixon's Q test myself, I'd attach a few examples from others instead, [Q test from Plotly](https://plotly.com/python/v3/outlier-test/) and also [Dixon's Q test for outlier identification -- a questionable practice](https://sebastianraschka.com/Articles/2014_dixon_test.html), since this dataset here wasn't quite normally distributed as shown from the histogram plotted above.\n\n::: {.cell execution_count=65}\n``` {.python .cell-code}\ndtree_san_df.boxplot(column = \"pIC50\")\n\n# the boxplot version below shows a blank background\n# rather than above version with horizontal grid lines\n#dtree_san_df.plot.box(column = \"pIC50\")\n```\n\n::: {.cell-output .cell-output-display execution_count=65}\n```\n<AxesSubplot: >\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Data_prep_files/figure-html/cell-66-output-2.png){width=566 height=411}\n:::\n:::\n\n\nSo I used Pandas' built-in boxplot in addition to the histogram to show the likely outliers within the pIC50 values. Clearly, the possible outliers for pIC50 values appeared to be close to 10 and above. I've then decided not to completely remove these outliers due to the dataset itself not in a Gaussian distribution (as they might not be true outliers).\n\n<br>\n\n#### **Molecular descriptors**\n\n",
    "supporting": [
      "Data_prep_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}